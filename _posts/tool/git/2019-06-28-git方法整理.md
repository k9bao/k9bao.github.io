---
layout: post
title: "git方法整理"
date: 2016-01-09 11:15:06 
description: "git方法整理"
tag: 工具集

---
# git相关概念整理
https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320  
## 名称解释：
**工作区(Working Copy)**：就是IDE或者vim或者notepad等等编辑工具，代表你正在工作的那个文件集  
**缓存区(INDEX)**：也叫本地Index,位于工作区与本地仓库的一个中间件，index:也被称为staging area，是指一整套即将被下一个提交的文件集合。他也是将成为HEAD的父亲的那个commit  
**本地仓库**:和远端仓库一样，只是存储在本地  
**远端仓库**:和本地仓库一样，有点共享的本地仓库样子，如果代码只有自己开发，并且只有自己可见，无需远端仓库  
**HEAD**：本地仓库指向的commit就叫HEAD  
**master:**主分支  
**dev:**开发分支  
**bug:** bug分支  
**feature:** 新功能分支  

## 命令整理
1. git add <file>: 添加文件到Git仓库,注意，可反复多次使用，添加多个文件,此操作会添加到暂存区
2. git branch: 查看分支
2. git branch <name>: 创建分支
2. git branch -d <name>: 删除分支
2. git branch -D <name>: 强行删除一个没有被合并过的分支
2. git branch --set-upstream branch-name origin/branch-name: 建立本地分支和远程分支的关联
3. git checkout <name>: 切换分支
3. git checkout -b branch-name origin/branch-name: 在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致
3. git checkout -b <name>: 创建+切换分支
3. git checkout -- file: 将缓冲区的文件checkout到工作区，丢弃工作区的修改
3. git commit -m <message>: 完成推送，推送到本地仓库,反向操作可以通过git reset操作
3. git clone: 克隆远端仓库到本地。ssh协议比https协议要快一些
3. git cherry-pick:
4. git diff:可以查看修改内容
5. git fetch: 修改FETCH_HEAD指向的commitID,一般fetch+merge代替git pull
5. git init: 初始化一个Git仓库
6. git log --graph:看到分支合并图
6. git log: 可以查看提交历史，以便确定要回退到哪个版本
7. git merge <name> --no-ff: 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
7. git merge <name>: 合并某分支到当前分支
8. git push -u origin master:第一次推送master分支的所有内容,后续推送不需要-u
9. git push -f:强制推送，覆盖origin的内容
8. git pull: 抓取远程的新提交
9. git reflog: 查看命令历史，以便确定要回到未来的哪个版本。
9. git reset --hard/--soft/--mixed commit_id: Git允许我们在版本的历史之间穿梭
9. git reset HEAD <file>: 将缓冲区的file丢弃
9. git rm --cached/-r <file>: 用于删除一个文件,和git add相对应,-f会同时删除本地文件，--cached会保留本地问题
9. git remote add origin git@server-name:path/repo-name.git:关联一个远程库
9. git remote -v: 查看远程库信息
9. git rebase: 操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。
10. git status:要随时掌握工作区的状态
10. git stash: 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug
10. git stash pop: 回到工作现场。
10. git stash list: 查看挂起的现场环境。

## 命令细化
### git rebase
**功能**：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；
1. **合并多个commit为一个完整commit**
[参考网址](https://www.jianshu.com/p/4a8f4af4e803)
+ git rebase -i  [startpoint]  [endpoint]  
//其中-i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint]  [endpoint]则指定了一个编辑区间的commitID，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。当然commit可以是HEAD~3 或者 HEAD^^^等可以代替commitID的内容
+ 根据提示(可能需要输入大写E)进入修改,除去startpoint不需要修改，其它将行将pick修改为squash，同时修改注释，然后保存OK,pick就是使用这个commit，squash意思是合并到pick的这个commit。  
2. **将当前branch的某一段commit粘贴到另一个分支上**
[参考网址](https://www.jianshu.com/p/4a8f4af4e803)
+ git rebase   [startpoint]   [endpoint]  --onto  [branchName]  
//其中，[startpoint]  [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，--onto的意思是要将该指定的提交复制到哪个分支上。
+ git reset --hard  0c72e64 修改branchName的HEAD指针指向最新commit
3. **将其它分支的某一段commit粘贴到本分支上**
+ git rebase branchName  [startpoint]   [endpoint]  
//参考上一条，只是无需使用--onto指定本分支，rebase后边跟需要获取的分支。
比如：git rebase master：就会将与master分离后的所有commit合并过来
 
## git branch
**功能**：分支相关操作
1. **在本地创建和远程分支对应的分支**(第一条是简写,第二条命令可以指定本地分支名称与远端不一样)：git checkout remoteBrName/git checkout -b branch-name origin/branch-name:
2. **查看所有本地分支**： git branch
3. **查看所有远端分支**： git branch -r
3. **查看所有本地和远端分支**： git branch -a
2. **创建本地分支**： git branch <name>
2. **删除本地分支**： git branch -d <name>
3. **删除远端分支**： git push origin --delete <name>  如果无法删除，可以先把本地的分支删除，然后使用git remote prune origin删除远端分支
2. **强行删除一个没有被合并过的分支**： git branch -D <name>
3. **删除远端不存在的本地分支**：git remote prune origin
2. **建立本地分支和远程分支的关联**：  
   git branch --set-upstream branch-name origin/branch-name
3. **切换分支**: git checkout <name>
3. **创建+切换分支**: git checkout -b <name>等价于git branch <name>+git checkout <name>

## git stash
**功能**:暂存相关操作
10. git stash: 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug
10. git stash pop: 回到工作现场。
10. git stash list: 查看挂起的现场环境。
11. git stash drop stash@{0}：清空第一个挂起
12. git stash clear:清空所有挂起

## git reset
**功能**：修改HEAD的指针[参考网址](https://www.cnblogs.com/kidsitcn/p/4513297.html)
**修改HEAD指针**：git reset --hard/--soft/--mixed commit_id
--soft：修改HEAD指向指定的commid
--mixed: 在--soft的基础上，本地缓存(INDEX)也变为commid相同内容，放弃本地缓存(INDEX)
--hard:在mixed的基础上，本地工作区
**将缓冲区的file丢弃**：git reset HEAD <file>

