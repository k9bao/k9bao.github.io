---
layout: post
title: ffmpeg编译理解
date: 2019-11-01 10:13:59
description: ffmpeg编译理解
tag: cmake

---


#  关于core的cmake编译解读
## 3rd/cmake
1. build.bat
+ C:\Windows\System32\chcp 65001>nul windows 控制台cmd乱码的解决办法.CHCP是一个计算机指令，能够显示或设置活动代码页编号。65001 UTF-8代码页
+ bat命令
  + set PROJECT_DIR=%CD% 通过set定义和设置变量,通过%%访问变量内容
  + rem和::都起到注释的作用，然而又有些不同。
    + rem是一条命令，在运行的时候相当于把rem本身及其后面的内容置空。既然它是一条命令，就必须处于单独的一行或者有类似“&”的连接符号连接。
    + 批处理遇到以冒号“:”开头的行时（忽略冒号前的空格），会将其后的语句识别为“标记”而不是命令语句，因此类似“:label”这样的东东在批处理中仅仅是一个标记。
    + 对于“::”而言，之所以可以达到注释的效果，是因为第二个:不是标签的合法字符（把它换成\;.等等都行），它不被当作一个合法的标签这一点很好理解，如果在你的批处理中有一个永远用不到的标签hero，那么你就可以用“:hero”打头来作为注释。只不过冒号有其先天的优越性--语法上的问题。
  + echo off和echo off,打开命令回显
  + pushd和 popd
    + 每次使用 pushd 命令时，都存储一个目录供用户使用。但是，可以通过多次使用 pushd 命令存储多个目录。
    + 目录按顺序储存到一个虚拟堆栈中。如果第一次使用 pushd 命令，该命令所在的目录就会被置于栈底。如果您再次使用该命令，则第二个目录就会被置于第一个目录之上。每次使用 pushd 命令时都将重复该过程。如果启用了命令扩展，pushd 命令将接收网络路径或本地驱动器盘符和路径。
    + 可以用 popd 命令将当前目录更改为由 pushd 命令最新存储的目录。如果使用 popd 命令，位于堆栈顶端的目录将从堆栈中删除，当前目录转变为栈顶目录。如果再次使用 popd 命令，则删除堆栈中的下一个目录。
    + 如果指定网络路径，pushd 命令临时将第一个未使用的驱动器盘符（从 Z 开始）分配到指定的网络资源。然后命令将当前驱动器和目录更改为新分配驱动器上的指定目录。如果与已启用的命令扩展一起使用 popd 命令，popd 命令将删除由 pushd 创建的驱动器盘符分配。
  + %cd% 可以用在批处理文件中，也可以用在命令行中;
    + 展开后，是驱动器盘符:+当前目录，如在dos窗口中进入c:\dir目录下面，输入：echo %cd% ，则显示为：c:\dir 。
    + %cd%的内容是可以被改变的，其内容为命令的执行路径或批处理文件的执行路径。
  + %Num : %0 指批处理本身。%1 指批处理文件名后加的以空格分隔的字符串。%2~%9类推
  + 
+ cmake命令行命令
  + -G :Specify a build system generator.比如:Ninja
  + -D <var>[:<type>]=<value>    = Create or update a cmake cache entry.
  + --build <dir> :Build a CMake-generated project binary tree.
  + --target <tgt> : Build <tgt> instead of default targets.
  + --             : Pass remaining options to the native tool.
  + --debug-output : 输出debug信息,显示命令由哪一行调用
+ helper.camke
  + macro(...)...endmacro(...) 定义红
  + function(<name> [arg1 [arg2 [arg3 ...]]])...endfunction(<name>)
    + 定义名为name的函数接受参数arg1,arg2...
    + 
  + function([TAG tagName] [ALL] show_variables)
    + 打印所有变量及内容,TAG及TAG后边的变量以及ALL字段除外.
    + TAG后边的变量,作为打印的标识,详见举例
    + ALL标识除了打印各个变量,同时各个变量与列表_CMAKE_CONFIGS内容分别组合后的变量也打印出来
    + 举例:
      + show_variables(TAG cmake EP_INSTALL_DIR) #[cmake] EP_INSTALL_DIR: C:/work/local/cpp_depends_v2
  + function(get_library_name(<VAR> <NAME> [TYPE STATIC|IMPORT|SHARED] [PREFIX override_prefix] [POSTFIX postfix]))
    + 根据输入参数,获取输出参数,如果输入参数有确认,默认使用系统参数,具体使用规则见函数实现.
    + 输入参数:VAR,NAME,TYPE,PREFIX,POSTFIX
    + 输出参数:VAR(=${PREFIX}${NAME}${POSTFIX}${CMAKE_DEBUG_POSTFIX}${CMAKE_${TYPE}_LIBRARY_SUFFIX})
    + 其中TYPE取值范围:STATIC|IMPORT|SHARED
  + function
+ compiler.cmake
  + 初始化CMAKE_RT_FLAGS list变量.MSVC模式有效,CMAKE_RT_FLAGS包括C/CXX的_DEBUG _RELEASE _MINSIZEREL _RELWITHDEBINFO四种模式,并且将MDd替换为MTD,MD替换为MT
  + 初始化MSVC_RT_VERSION变量.MSVC模式有效,意思使用的VC版本号
+ abseil.cmake
  + 调用函数get_library_name,根据absl_strings设置变量absl_strings_LIBRARY的内容
  + 调用ExternalProject_Add编译外部依赖库(具体详见abseil压缩包)
  + 生成对应的.PC文件,通过调用set(PC_NAME,...),set(PC_VERSION,...),set(PC_LDFLAGS,...),configure_file(tmpl.pc.in ... @ONLY)函数