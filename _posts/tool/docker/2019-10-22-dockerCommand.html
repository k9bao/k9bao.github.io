<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>docker常用命令</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <hr>
<p>layout: post
title: dockerCommand
date: 2019-11-01 10:13:58
description: dockerCommand
tag: docker</p>
<hr>
<h1 id="docker%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4">docker常用命令</h1>
<ul>
<li><a href="#docker%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4">docker常用命令</a>
<ul>
<li><a href="#11-%e5%90%8d%e7%a7%b0%e8%a7%a3%e9%87%8a">1.1. 名称解释</a>
<ul>
<li><a href="#111-%e7%8e%84%e8%99%9a%e9%95%9c%e5%83%8f">1.1.1. 玄虚镜像</a></li>
</ul>
</li>
<li><a href="#12-docker-%e5%91%bd%e4%bb%a4%e6%9f%a5%e8%af%a2">1.2. Docker 命令查询</a>
<ul>
<li><a href="#121-%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">1.2.1. 基本语法</a></li>
<li><a href="#122-client-option">1.2.2. client-OPTION</a></li>
<li><a href="#123-client-command">1.2.3. client-COMMAND</a>
<ul>
<li><a href="#1231-client-a-c">1.2.3.1. client-A-C</a></li>
<li><a href="#1232-client-d-h">1.2.3.2. client-D-H</a></li>
<li><a href="#1233-client-i-k">1.2.3.3. client-I-K</a></li>
<li><a href="#1234-client-l-p">1.2.3.4. client-L-P</a></li>
<li><a href="#1235-client-r-s">1.2.3.5. client-R-S</a></li>
<li><a href="#1236-client-t-z">1.2.3.6. client-T-Z</a></li>
</ul>
</li>
<li><a href="#124-server-option">1.2.4. server-OPTION</a>
<ul>
<li><a href="#1241-server-a-c">1.2.4.1. server-A-C</a></li>
<li><a href="#1242-server-d-f">1.2.4.2. server-D-F</a></li>
<li><a href="#1243-server-g-i">1.2.4.3. server-G-I</a></li>
<li><a href="#1244-server-l-s">1.2.4.4. server-L-S</a></li>
<li><a href="#1245-server-t-z">1.2.4.5. server-T-Z</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">1.3. 参考资料</a></li>
</ul>
</li>
</ul>
<h2 id="11-%e5%90%8d%e7%a7%b0%e8%a7%a3%e9%87%8a">1.1. 名称解释</h2>
<h3 id="111-%e7%8e%84%e8%99%9a%e9%95%9c%e5%83%8f">1.1.1. 玄虚镜像</h3>
<pre><code>仓库名、标签均为 &lt;none&gt; 的镜像
</code></pre>
<h2 id="12-docker-%e5%91%bd%e4%bb%a4%e6%9f%a5%e8%af%a2">1.2. Docker 命令查询</h2>
<p><img src="file:///c:\gwork\knowledgebao\knowledgebao.github.io\_posts\tool\docker\img\cmd_logic.png" alt="命令图"></p>
<h3 id="121-%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">1.2.1. 基本语法</h3>
<p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。可以通过 man docker 或 docker help 来查看这些命令。</p>
<p>客户端命令：基本命令格式为 docker [OPTIONS] COMMAND [arg...]；
更多参数说明请使用 docker &quot;commit&quot; --help 查看。其中commit就是对于的命令</p>
<p>服务端命令：基本命令格式为 dockerd [OPTIONS]。
更多参数说明请使用 docker &quot;commit&quot; --help 查看。其中commit就是对于的命令</p>
<p>具体OPTION和COMMAND，详见 <a href="#122-client-option">client-OPTION</a>,<a href="#124-server-option">server-OPTION</a>,<a href="#123-client-command">client-COMMAND</a></p>
<h3 id="122-client-option">1.2.2. client-OPTION</h3>
<ul>
<li>--config=&quot;&quot;
指定客户端配置文件，默认为 ~/.docker；</li>
<li>-D=true|false
是否使用 debug 模式。默认不开启；</li>
<li>-H, --host=[]
指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；</li>
<li>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;
指定日志输出级别</li>
<li>--tls=true|false
是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li>--tlscacert=/.docker/ca.pem
TLS CA 签名的可信证书文件路径；</li>
<li>--tlscert=/.docker/cert.pem
TLS 可信证书文件路径；</li>
<li>--tlscert=/.docker/key.pem：TLS
密钥文件路径；</li>
<li>--tlsverify=true|false
启用 TLS 校验，默认为否。</li>
</ul>
<h3 id="123-client-command">1.2.3. client-COMMAND</h3>
<p>可以通过 docker COMMAND --help 来查看这些命令的具体用法。</p>
<h4 id="1231-client-a-c">1.2.3.1. client-A-C</h4>
<ul>
<li>attach
<ol>
<li>依附到一个正在运行的容器中；</li>
<li>某些时候需要进入容器进行操作，包括使用 docker attach 命令,后边直接跟镜像ID</li>
<li>通过attach进入容器,如果从进入后的stdin 中 exit，会导致容器的停止。所以不推荐使用此命令,推介使用docker exec -it</li>
</ol>
</li>
<li>build
<ol>
<li>docker build [选项] &lt;上下文路径/URL/-&gt;</li>
<li>从一个 Dockerfile 创建一个镜像；</li>
<li>-f ../Dockerfile.php 指定某个文件作为 Dockerfile。</li>
<li>docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建:<code>docker build https://github.com/twang2218/gitlab-ce-zh.git#:11.1</code></li>
<li>用给定的 tar 压缩包构建: <code>docker build http://server/context.tar.gz</code></li>
<li>从标准输入中读取 Dockerfile 进行构建<code>docker build - &lt; Dockerfile</code>或<code>cat Dockerfile | docker build -</code></li>
<li>从标准输入中读取上下文压缩包进行构建<code>$ docker build - &lt; context.tar.gz</code>,如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</li>
<li>镜像构建上下文（Context）
<ul>
<li>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</li>
<li>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</li>
<li>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。
如果在 Dockerfile 中这么写：<code>COPY ./package.json /app/</code>
这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。</li>
<li>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</li>
</ul>
</li>
</ol>
</li>
<li>commit
<ol>
<li>从一个容器的修改中创建一个新的镜像；</li>
<li>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]],使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用,实际使用Dockerfile定制镜像。</li>
<li><strong>--author</strong> 是指定修改的作者</li>
<li><strong>--message</strong> 则是记录本次修改的内容</li>
</ol>
</li>
<li>docker container
<ol>
<li><strong>start</strong>: 直接将一个已经终止的容器启动运行。</li>
<li><strong>stop</strong>:  来终止一个运行中的容器</li>
<li><strong>rm</strong>:    删除一个处于终止状态的容器,如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</li>
<li><strong>prune</strong>: 清理掉所有处于终止状态的容器。</li>
<li><strong>ls -a</strong>: 可以查看所有已经创建的包括终止状态的容器: 可以查看所有已经创建的包括终止状态的容器</li>
</ol>
</li>
<li>cp
<ol>
<li>在容器和本地宿主系统之间复制文件中；</li>
</ol>
</li>
<li>create
<ol>
<li>创建一个新容器，但并不运行它；</li>
</ol>
</li>
</ul>
<h4 id="1232-client-d-h">1.2.3.2. client-D-H</h4>
<ul>
<li>diff
<ol>
<li>检查一个容器内文件系统的修改，包括修改和增加；</li>
</ol>
</li>
<li>events
<ol>
<li>从服务端获取实时的事件；</li>
</ol>
</li>
<li>exec
<ol>
<li>在运行的容器内执行命令；此命令也可以进入容器</li>
<li><strong>-i</strong> CONTAINER ID: 进入容器,但是没有命令提示符</li>
<li><strong>-it</strong> CONTAINER ID: 进入容器,有命令提示符</li>
</ol>
</li>
<li>export
<ol>
<li>导出容器内容为一个 tar 包；</li>
<li>导出本地某个容器快照,比如:docker export 7691a814370e &gt; ubuntu.tar</li>
</ol>
</li>
<li>history
<ol>
<li>显示一个镜像的历史信息；</li>
</ol>
</li>
</ul>
<h4 id="1233-client-i-k">1.2.3.3. client-I-K</h4>
<ul>
<li>image ls
<ol>
<li>显示所有顶层镜像,也可以直接加&quot;仓库名&quot;或者&quot;仓库名:标签&quot;来精确搜索镜像,如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</li>
<li><strong>-f dangling=true</strong> 过滤出玄虚镜像</li>
<li><strong>-f</strong> 表示过滤的意思,有点类似grep,也可以写为--format</li>
<li><strong>-f since=mongo:3.2</strong> 显示mongo:3.2之后的版本</li>
<li><strong>-f since=before:3.2</strong> 显示mongo:3.2之前的版本</li>
<li><strong>-f &quot;{{.ID}}: {{.Repository}}&quot;</strong> 只显示ID和仓库名,这是模板语法</li>
<li><strong>-f &quot;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&quot;</strong> 按指定顺序显示列</li>
<li><strong>-a</strong> 同时显示中间层镜像(中间层镜像只会被保存一份)</li>
<li><strong>-q</strong> 只显示ID</li>
<li><strong>prune</strong> 删除玄虚镜像(仓库名、标签均为 none 的镜像)</li>
</ol>
</li>
<li>image rm
<ol>
<li>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...],其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名(&lt;仓库名&gt;:&lt;标签&gt;) 或者 镜像摘要。</li>
<li>所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已,有可能由于其他依赖无法删除.比如某一层被其他进行依赖,或者进行有容器对其依赖都无法删除</li>
<li>可以结合ls命令来删除指定镜像,比如删除所有仓库名为 redis 的镜像:<br>
docker image rm $(docker image ls -q redis)</li>
</ol>
</li>
<li>images
列出存在的镜像；</li>
<li>import
<ol>
<li>导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</li>
<li>从容器快照文件中再导入为镜像,比如:cat ubuntu.tar | docker import - test/ubuntu:v1.0</li>
<li>此外，也可以通过指定 URL 或者某个目录来导入docker import <a href="http://example.com/exampleimage.tgz">http://example.com/exampleimage.tgz</a> example/imagerepo</li>
<li>容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态）,从容器快照文件导入时可以重新指定标签等元数据信息,而docker load不可以修改.</li>
</ol>
</li>
<li>info
<ol>
<li>显示一些相关的系统信息；</li>
</ol>
</li>
<li>inspect
<ol>
<li>显示一个容器的具体配置信息；</li>
</ol>
</li>
<li>kill
<ol>
<li>关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
</ol>
</li>
</ul>
<h4 id="1234-client-l-p">1.2.3.4. client-L-P</h4>
<ul>
<li>load
<ol>
<li>从一个 tar 包中加载一个镜像；</li>
<li>导入镜像存储文件到本地镜像库</li>
<li>镜像存储文件将保存完整记录，体积也要大。</li>
</ol>
</li>
<li>login
<ol>
<li>注册或登录到一个 Docker 的仓库服务器；</li>
</ol>
</li>
<li>logout
<ol>
<li>从 Docker 的仓库服务器登出；</li>
</ol>
</li>
<li>logs
<ol>
<li>获取容器的 log 信息；</li>
</ol>
</li>
<li>network
<ol>
<li>管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
</ol>
</li>
<li>node
<ol>
<li>管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li>
</ol>
</li>
<li>pause
<ol>
<li>暂停一个容器中的所有进程；</li>
</ol>
</li>
<li>port
<ol>
<li>查找一个 nat 到一个私有网口的公共口；</li>
</ol>
</li>
<li>ps
<ol>
<li>列出主机上的容器；</li>
</ol>
</li>
<li>pull
<ol>
<li>从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li>具体的选项可以通过 docker pull --help 命令看到
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</li>
</ol>
</li>
<li>push
<ol>
<li>将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
</ol>
</li>
</ul>
<h4 id="1235-client-r-s">1.2.3.5. client-R-S</h4>
<ul>
<li>rename
<ol>
<li>重命名一个容器；</li>
</ol>
</li>
<li>restart
<ol>
<li>重启一个运行中的容器；</li>
</ol>
</li>
<li>rm
<ol>
<li>删除给定的若干个容器；</li>
</ol>
</li>
<li>rmi
<ol>
<li>删除给定的若干个镜像；</li>
</ol>
</li>
<li>run
<ol>
<li>创建一个新容器，并在其中运行给定命令；</li>
<li>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
</li>
<li>具体参数
<ul>
<li><strong>-d</strong>:让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下</li>
</ul>
</li>
</ol>
</li>
<li>save
<ol>
<li>保存一个镜像为 tar 包文件；</li>
</ol>
</li>
<li>search
<ol>
<li>在 Docker index 中搜索一个镜像；</li>
</ol>
</li>
<li>service
<ol>
<li>管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
</ol>
</li>
<li>start
<ol>
<li>启动一个容器；</li>
</ol>
</li>
<li>stats
<ol>
<li>输出（一个或多个）容器的资源使用统计信息；</li>
</ol>
</li>
<li>stop
<ol>
<li>终止一个运行中的容器；</li>
</ol>
</li>
<li>swarm
<ol>
<li>管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
</ol>
</li>
<li>system df
<ol>
<li>查看镜像、容器、数据卷所占用的空间。</li>
</ol>
</li>
</ul>
<h4 id="1236-client-t-z">1.2.3.6. client-T-Z</h4>
<ul>
<li>tag
<ol>
<li>为一个镜像打标签；</li>
</ol>
</li>
<li>top
<ol>
<li>查看一个容器中的正在运行的进程信息；</li>
</ol>
</li>
<li>unpause
<ol>
<li>将一个容器内所有的进程从暂停状态中恢复；</li>
</ol>
</li>
<li>update
<ol>
<li>更新指定的若干容器的配置信息；</li>
</ol>
</li>
<li>version
<ol>
<li>输出 Docker 的版本信息；</li>
</ol>
</li>
<li>volume
<ol>
<li>管理 Docker volume，包括查看、创建、删除等；</li>
</ol>
</li>
<li>wait
<ol>
<li>阻塞直到一个容器终止，然后输出它的退出符。</li>
</ol>
</li>
<li>Dockerfile指令
<a href="Dockerfile.md">详见Dockerfile.md</a></li>
</ul>
<h3 id="124-server-option">1.2.4. server-OPTION</h3>
<h4 id="1241-server-a-c">1.2.4.1. server-A-C</h4>
<ul>
<li>api-cors-header=&quot;&quot;<br>
CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 &quot;*&quot;；</li>
<li>authorization-plugin=&quot;&quot;<br>
载入认证的插件；</li>
<li>-b=&quot;&quot;<br>
将容器挂载到一个已存在的网桥上。指定为 none 时则禁用容器的网络，与 - bip 选项互斥；</li>
<li>bip=&quot;&quot;<br>
让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</li>
<li>cgroup-parent=&quot;&quot;<br>
指定 cgroup 的父组，默认 fs cgroup 驱动为 /docker，systemd cgroup 驱动为 system.slice；</li>
<li>cluster-store=&quot;&quot;<br>
构成集群（如 Swarm）时，集群键值数据库服务地址；</li>
<li>cluster-advertise=&quot;&quot;<br>
构成集群时，自身的被访问地址，可以为 host:port 或 interface:port；</li>
<li>cluster-store-opt=&quot;&quot;<br>
构成集群时，键值数据库的配置选项；</li>
<li>config-file=&quot;/etc/docker/daemon.json&quot;<br>
daemon 配置文件路径；</li>
<li>containerd=&quot;&quot;<br>
containerd 文件的路径；</li>
</ul>
<h4 id="1242-server-d-f">1.2.4.2. server-D-F</h4>
<ul>
<li>-D, --debug=true|false<br>
是否使用 Debug 模式。缺省为 false；</li>
<li>default-gateway=&quot;&quot;<br>
容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li>default-gateway-v6=&quot;&quot;<br>
容器的 IPv6 网关地址；</li>
<li>default-ulimit=[]<br>
默认的 ulimit 值；</li>
<li>disable-legacy-registry=true|false<br>
是否允许访问旧版本的镜像仓库服务器；</li>
<li>dns=&quot;&quot;<br>
指定容器使用的 DNS 服务器地址；</li>
<li>dns-opt=&quot;&quot;<br>
DNS 选项；</li>
<li>dns-search=[]<br>
DNS 搜索域；</li>
<li>exec-opt=[]<br>
运行时的执行选项；</li>
<li>exec-root=&quot;&quot;<br>
容器执行状态文件的根路径，默认为 /var/run/docker；</li>
<li>fixed-cidr=&quot;&quot;<br>
限定分配 IPv4 地址范围；</li>
<li>fixed-cidr-v6=&quot;&quot;<br>
限定分配 IPv6 地址范围；</li>
</ul>
<h4 id="1243-server-g-i">1.2.4.3. server-G-I</h4>
<ul>
<li>-G, --group=&quot;&quot;<br>
分配给 unix 套接字的组，默认为 docker；</li>
<li>-g, --graph=&quot;&quot;<br>
Docker 运行时的根路径，默认为 /var/lib/docker；</li>
<li>-H, --host=[]<br>
指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；</li>
<li>icc=true|false<br>
是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li>insecure-registry=[]<br>
允许访问给定的非安全仓库服务；</li>
<li>ip=&quot;&quot;<br>
绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</li>
<li>ip-forward=true|false<br>
是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li>ip-masq=true|false<br>
是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li>iptables=true|false<br>
是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li>ipv6=true|false<br>
是否启用 IPv6 支持，默认关闭；</li>
</ul>
<h4 id="1244-server-l-s">1.2.4.4. server-L-S</h4>
<ul>
<li>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;<br>
指定日志输出级别；</li>
<li>label=&quot;[]&quot;<br>
添加指定的键值对标注；</li>
<li>log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;<br>
指定日志后端驱动，默认为 json-file；</li>
<li>log-opt=[]<br>
日志后端的选项；</li>
<li>mtu=VALUE<br>
指定容器网络的 mtu；</li>
<li>-p=&quot;&quot;<br>
指定 daemon 的 PID 文件路径。缺省为 /var/run/docker.pid；</li>
<li>--raw-logs<br>
输出原始，未加色彩的日志信息；</li>
<li><code>registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code><br>
指定 docker pull 时使用的注册服务器镜像地址；</li>
<li>-s, --storage-driver=&quot;&quot;<br>
指定使用给定的存储后端；</li>
<li>selinux-enabled=true|false<br>
是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li>storage-opt=[]<br>
驱动后端选项；</li>
</ul>
<h4 id="1245-server-t-z">1.2.4.5. server-T-Z</h4>
<ul>
<li>tls=true|false<br>
是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li>tlscacert=/.docker/ca.pem<br>
TLS CA 签名的可信证书文件路径；</li>
<li>tlscert=/.docker/cert.pem<br>
TLS 可信证书文件路径；</li>
<li>tlscert=/.docker/key.pem<br>
TLS 密钥文件路径；</li>
<li>tlsverify=true|false<br>
启用 TLS 校验，默认为否；</li>
<li>userland-proxy=true|false<br>
是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li>userns-remap=default|uid:gid|user:group|user|uid<br>
指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h2 id="13-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">1.3. 参考资料</h2>
<p>1.<a href="https://docker_practice.gitee.io/zh-cn/appendix/command/">Docker 命令查询</a></p>

    </body>
    </html>